#code generated by ChatGPT

import os
import esp
import uos

esp.osdebug(None)

try:
    import uos
    from flashbdev import bdev

    uos.mount(bdev, "/spiffs")
except OSError as e:
    print("SPIFFS mount failed:", e)

# Upewnij się, że SPIFFS jest zamontowany poprawnie
print("Files on SPIFFS:", uos.listdir('/spiffs'))

def printProgressBar(iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = '█', printEnd = "\r"):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        decimals    - Optional  : positive number of decimals in percent complete (Int)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
        printEnd    - Optional  : end character (e.g. "\r", "\r\n") (Str)
    """
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
    # Print New Line on Complete
    if iteration == total: 
        print()


def save_dual_buffers_as_bmp(black_buffer, red_buffer, width, height, filename):
    # Rozmiar obrazu w bajtach, uwzględniając wyrównanie do 4 bajtów na wiersz
    row_size = width * 3
    row_padding = (4 - (row_size % 4)) % 4
    image_size = (row_size + row_padding) * height

    # Utworzenie nagłówka BMP
    filesize = 54 + image_size  # 54 bajty nagłówka BMP, reszta to dane obrazu
    bmp_header = bytearray([
        0x42, 0x4D,             # Signature 'BM'
        filesize & 0xFF, (filesize >> 8) & 0xFF, (filesize >> 16) & 0xFF, (filesize >> 24) & 0xFF,
        0, 0, 0, 0,             # Reserved
        54, 0, 0, 0,            # Offset to start of image data (54)
        40, 0, 0, 0,            # Header size
        width & 0xFF, (width >> 8) & 0xFF, (width >> 16) & 0xFF, (width >> 24) & 0xFF,
        height & 0xFF, (height >> 8) & 0xFF, (height >> 16) & 0xFF, (height >> 24) & 0xFF,
        1, 0,                   # Planes
        24, 0,                  # Bits per pixel (24-bit color)
        0, 0, 0, 0,             # Compression (none)
        image_size & 0xFF, (image_size >> 8) & 0xFF, (image_size >> 16) & 0xFF, (image_size >> 24) & 0xFF,
        0x13, 0x0B, 0, 0,       # X pixels per meter (2835)
        0x13, 0x0B, 0, 0,       # Y pixels per meter (2835)
        0, 0, 0, 0,             # Number of colors in the color palette
        0, 0, 0, 0              # Important colors
    ])

    # Otwarcie pliku do zapisu
    with open('/spiffs/' + filename, 'wb') as f:
        f.write(bmp_header)

        row_size_bytes = (width + 7) // 8  # liczba bajtów na wiersz w buforze bitowym
        
        printProgressBar(0, height -1, prefix = 'Progress:', suffix = 'Complete', length = 50)

        for y in range(height - 1, -1, -1):  # BMP zapisuje wiersze od dołu do góry
            row_data = bytearray()
            for x in range(width):
                byte_index = (y * row_size_bytes) + (x // 8)
                bit_index = 7 - (x % 8)

                black_bit = (black_buffer[byte_index] >> bit_index) & 1
                red_bit = (red_buffer[byte_index] >> bit_index) & 1

                # Kombinacja wartości z obu buforów z priorytetem dla czerwonego
                if red_bit == 0:
                    # Czerwony
                    row_data += bytearray([0, 0, 255])
                elif black_bit == 0:
                    # Czarny
                    row_data += bytearray([0, 0, 0])
                else:
                    # Biały (oba bity ustawione na 1)
                    row_data += bytearray([255, 255, 255])
            row_data += bytearray([0] * row_padding)  # Wyrównanie do 4 bajtów
            f.write(row_data)
            printProgressBar(height - y -1, height-1, prefix = 'Progress:', suffix = 'Complete', length = 50)
            

#QOI compression

# QOI format constants
QOI_HEADER_SIZE = 14
QOI_PADDING_SIZE = 8
QOI_OP_RGB = 0xFE
QOI_OP_INDEX = 0x00
QOI_OP_DIFF = 0x40
QOI_OP_LUMA = 0x80
QOI_OP_RUN = 0xC0
QOI_OP_MASK = 0xC0

def qoi_write_header(filename, width, height):
    header = bytearray(14)
    header[0:4] = b'qoif'  # Magic number
    header[4:8] = width.to_bytes(4, 'big')
    header[8:12] = height.to_bytes(4, 'big')
    header[12] = 3  # Channels (RGB)
    header[13] = 0  # Colorspace (sRGB with linear alpha)

    with open('/mnt/data/' + filename, 'wb') as f:
        f.write(header)

def qoi_write_pixel_data(filename, width, height, black_buffer, red_buffer):
    row_size_bytes = (width + 7) // 8  # liczba bajtów na wiersz w buforze bitowym

    with open('/mnt/data/' + filename, 'ab') as f:
        # Initialize the QOI index
        index = [(0, 0, 0, 255)] * 64
        run = 0
        prev_pixel = (0, 0, 0, 255)

        for y in range(height):
            for x in range(width):
                byte_index = (y * row_size_bytes) + (x // 8)
                bit_index = 7 - (x % 8)

                black_bit = (black_buffer[byte_index] >> bit_index) & 1
                red_bit = (red_buffer[byte_index] >> bit_index) & 1

                # Kombinacja wartości z obu buforów z priorytetem dla czerwonego
                if red_bit == 0:
                    pixel = (255, 0, 0, 255)  # Czerwony
                elif black_bit == 0:
                    pixel = (0, 0, 0, 255)  # Czarny
                else:
                    pixel = (255, 255, 255, 255)  # Biały

                if pixel == prev_pixel:
                    run += 1
                    if run == 62:
                        f.write(bytearray([QOI_OP_RUN | (run - 1)]))
                        run = 0
                else:
                    if run > 0:
                        f.write(bytearray([QOI_OP_RUN | (run - 1)]))
                        run = 0
                    r, g, b, a = pixel
                    index_pos = (r * 3 + g * 5 + b * 7 + a * 11) % 64
                    if index[index_pos] == pixel:
                        f.write(bytearray([QOI_OP_INDEX | index_pos]))
                    else:
                        index[index_pos] = pixel
                        f.write(bytearray([QOI_OP_RGB, r, g, b]))
                prev_pixel = pixel

        if run > 0:
            f.write(bytearray([QOI_OP_RUN | (run - 1)]))

        # Add the QOI end marker
        f.write(bytearray([0, 0, 0, 0, 0, 0, 0, 1]))

def save_dual_buffers_as_qoi(black_buffer, red_buffer, width, height, filename):
    qoi_write_header(filename, width, height)
    qoi_write_pixel_data(filename, width, height, black_buffer, red_buffer)
